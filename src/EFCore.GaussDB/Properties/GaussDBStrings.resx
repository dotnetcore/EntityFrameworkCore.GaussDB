<?xml version="1.0" encoding="utf-8"?>
<root>
  <!-- 
    Microsoft ResX Schema 
    
    Version 2.0
    
    The primary goals of this format is to allow a simple XML format 
    that is mostly human readable. The generation and parsing of the 
    various data types are done through the TypeConverter classes 
    associated with the data types.
    
    Example:
    
    ... ado.net/XML headers & schema ...
    <resheader name="resmimetype">text/microsoft-resx</resheader>
    <resheader name="version">2.0</resheader>
    <resheader name="reader">System.Resources.ResXResourceReader, System.Windows.Forms, ...</resheader>
    <resheader name="writer">System.Resources.ResXResourceWriter, System.Windows.Forms, ...</resheader>
    <data name="Name1"><value>this is my long string</value><comment>this is a comment</comment></data>
    <data name="Color1" type="System.Drawing.Color, System.Drawing">Blue</data>
    <data name="Bitmap1" mimetype="application/x-microsoft.net.object.binary.base64">
        <value>[base64 mime encoded serialized .NET Framework object]</value>
    </data>
    <data name="Icon1" type="System.Drawing.Icon, System.Drawing" mimetype="application/x-microsoft.net.object.bytearray.base64">
        <value>[base64 mime encoded string representing a byte array form of the .NET Framework object]</value>
        <comment>This is a comment</comment>
    </data>
                
    There are any number of "resheader" rows that contain simple 
    name/value pairs.
    
    Each data row contains a name, and value. The row also contains a 
    type or mimetype. Type corresponds to a .NET class that support 
    text/value conversion through the TypeConverter architecture. 
    Classes that don't support this are serialized and stored with the 
    mimetype set.
    
    The mimetype is used for serialized objects, and tells the 
    ResXResourceReader how to depersist the object. This is currently not 
    extensible. For a given mimetype the value must be set accordingly:
    
    Note - application/x-microsoft.net.object.binary.base64 is the format 
    that the ResXResourceWriter will generate, however the reader can 
    read any of the formats listed below.
    
    mimetype: application/x-microsoft.net.object.binary.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Binary.BinaryFormatter
            : and then encoded with base64 encoding.
    
    mimetype: application/x-microsoft.net.object.soap.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Soap.SoapFormatter
            : and then encoded with base64 encoding.

    mimetype: application/x-microsoft.net.object.bytearray.base64
    value   : The object must be serialized into a byte array 
            : using a System.ComponentModel.TypeConverter
            : and then encoded with base64 encoding.
    -->
  <xsd:schema id="root" xmlns="" xmlns:xsd="http://www.w3.org/2001/XMLSchema" xmlns:msdata="urn:schemas-microsoft-com:xml-msdata">
    <xsd:import namespace="http://www.w3.org/XML/1998/namespace" />
    <xsd:element name="root" msdata:IsDataSet="true">
      <xsd:complexType>
        <xsd:choice maxOccurs="unbounded">
          <xsd:element name="metadata">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" />
              </xsd:sequence>
              <xsd:attribute name="name" use="required" type="xsd:string" />
              <xsd:attribute name="type" type="xsd:string" />
              <xsd:attribute name="mimetype" type="xsd:string" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="assembly">
            <xsd:complexType>
              <xsd:attribute name="alias" type="xsd:string" />
              <xsd:attribute name="name" type="xsd:string" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="data">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
                <xsd:element name="comment" type="xsd:string" minOccurs="0" msdata:Ordinal="2" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" msdata:Ordinal="1" />
              <xsd:attribute name="type" type="xsd:string" msdata:Ordinal="3" />
              <xsd:attribute name="mimetype" type="xsd:string" msdata:Ordinal="4" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="resheader">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" />
            </xsd:complexType>
          </xsd:element>
        </xsd:choice>
      </xsd:complexType>
    </xsd:element>
  </xsd:schema>
  <resheader name="resmimetype">
    <value>text/microsoft-resx</value>
  </resheader>
  <resheader name="version">
    <value>2.0</value>
  </resheader>
  <resheader name="reader">
    <value>System.Resources.ResXResourceReader, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <resheader name="writer">
    <value>System.Resources.ResXResourceWriter, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <data name="DataSourceAndConfigNotSupported" xml:space="preserve">
    <value>ConfigureDataSource() cannot be used when an externally-provided GaussDBDataSource is passed to UseGaussDB(). Either perform all data source configuration on the external GaussDBDataSource, or pass a connection string to UseGaussDB() and specify the data source configuration there.</value>
  </data>
  <data name="DuplicateColumnCompressionMethodMismatch" xml:space="preserve">
    <value>'{entityType1}.{property1}' and '{entityType2}.{property2}' are both mapped to column '{columnName}' in '{table}' but are configured with different compression methods.</value>
  </data>
  <data name="DuplicateColumnNameValueGenerationStrategyMismatch" xml:space="preserve">
    <value>'{entityType1}.{property1}' and '{entityType2}.{property2}' are both mapped to column '{columnName}' in '{table}' but are configured with different value generation strategies.</value>
  </data>
  <data name="DuplicateIndexCollationMismatch" xml:space="preserve">
    <value>The indexes {index1} on '{entityType1}' and {index2} on '{entityType2}' are both mapped to '{table}.{indexName}', but have different collation configurations.</value>
  </data>
  <data name="DuplicateIndexConcurrentCreationMismatch" xml:space="preserve">
    <value>The indexes {index1} on '{entityType1}' and {index2} on '{entityType2}' are both mapped to '{table}.{indexName}', but have different concurrent creation configurations.</value>
  </data>
  <data name="DuplicateIndexIncludedMismatch" xml:space="preserve">
    <value>The indexes {index1} on '{entityType1}' and {index2} on '{entityType2}' are both mapped to '{table}.{indexName}', but have different included columns: {includedColumns1} and {includedColumns2}.</value>
  </data>
  <data name="Ef7JsonMappingNotSupported" xml:space="preserve">
    <value>The EF Core 7.0 JSON support isn't currently supported by the GaussDB provider. To map to JSON, see https://www.GaussDB.org/efcore/mapping/json.html.</value>
  </data>
  <data name="FreeTextFunctionOnClient" xml:space="preserve">
    <value>The 'FreeText' method is not supported because the query has switched to client-evaluation. Inspect the log to determine which query expressions are triggering client-evaluation.</value>
  </data>
  <data name="HeterogeneousTypesInNewArray" xml:space="preserve">
    <value>Heterogeneous store types detected when making new array ({type1}, {type2}).</value>
  </data>
  <data name="IncludePropertyDuplicated" xml:space="preserve">
    <value>Include property '{entityType}.{property}' cannot be defined multiple times</value>
  </data>
  <data name="IncludePropertyInIndex" xml:space="preserve">
    <value>Include property '{entityType}.{property}' is already included in the index</value>
  </data>
  <data name="IncludePropertyNotFound" xml:space="preserve">
    <value>Include property '{entityType}.{property}' not found</value>
  </data>
  <data name="InvalidTableToIncludeInScaffolding" xml:space="preserve">
    <value>The specified table '{table}' is not valid. Specify tables using the format '[schema].[table]'.</value>
  </data>
  <data name="LogEnumColumnSkipped" xml:space="preserve">
    <value>Enum column '{name}' cannot be scaffolded, define a CLR enum type and add the property manually.</value>
    <comment>Warning GaussDBEventId.EnumColumnSkippedWarning string</comment>
  </data>
  <data name="LogExpressionIndexSkipped" xml:space="preserve">
    <value>Expression index '{name}' on table {tableName} cannot be scaffolded, expression indices aren't supported and must be added via raw SQL in migrations.</value>
    <comment>Warning GaussDBEventId.ExpressionIndexSkippedWarning string string</comment>
  </data>
  <data name="LogFoundCollation" xml:space="preserve">
    <value>Found collation with name: {collationName}, schema: {schema}, LC_COLLATE: {lcCollate}, LC_CTYPE: {lcCtype}, provider: {provider}, deterministic: {isDeterministic}</value>
    <comment>Debug GaussDBEventId.CollationFound string string string string string? bool</comment>
  </data>
  <data name="LogFoundColumn" xml:space="preserve">
    <value>Found column with table: {tableName}, column name: {columnName}, data type: {dataType}, nullable: {isNullable}, identity: {isIdentity}, default value: {defaultValue}, computed value: {computedValue}</value>
    <comment>Debug GaussDBEventId.ColumnFound string string string bool bool string string</comment>
  </data>
  <data name="LogFoundForeignKey" xml:space="preserve">
    <value>Found foreign key on table: {tableName}, name: {foreignKeyName}, principal table: {principalTableName}, delete action: {deleteAction}.</value>
    <comment>Debug GaussDBEventId.ForeignKeyFound string string string string</comment>
  </data>
  <data name="LogFoundIndex" xml:space="preserve">
    <value>Found index with name: {indexName}, table: {tableName}, is unique: {isUnique}.</value>
    <comment>Debug GaussDBEventId.IndexFound string string bool</comment>
  </data>
  <data name="LogFoundPrimaryKey" xml:space="preserve">
    <value>Found primary key with name: {primaryKeyName}, table: {tableName}.</value>
    <comment>Debug GaussDBEventId.PrimaryKeyFound string string</comment>
  </data>
  <data name="LogFoundSequence" xml:space="preserve">
    <value>Found sequence name: {name}, data type: {dataType}, cyclic: {isCyclic}, increment: {increment}, start: {start}, minimum: {min}, maximum: {max}.</value>
    <comment>Debug GaussDBEventId.SequenceFound string string bool int long long long</comment>
  </data>
  <data name="LogFoundTable" xml:space="preserve">
    <value>Found table with name: {name}.</value>
    <comment>Debug GaussDBEventId.TableFound string</comment>
  </data>
  <data name="LogFoundUniqueConstraint" xml:space="preserve">
    <value>Found unique constraint with name: {uniqueConstraintName}, table: {tableName}.</value>
    <comment>Debug GaussDBEventId.UniqueConstraintFound string? string</comment>
  </data>
  <data name="LogMissingSchema" xml:space="preserve">
    <value>Unable to find a schema in the database matching the selected schema {schema}.</value>
    <comment>Warning GaussDBEventId.MissingSchemaWarning string?</comment>
  </data>
  <data name="LogMissingTable" xml:space="preserve">
    <value>Unable to find a table in the database matching the selected table {table}.</value>
    <comment>Warning GaussDBEventId.MissingTableWarning string?</comment>
  </data>
  <data name="LogPrincipalColumnNotFound" xml:space="preserve">
    <value>For foreign key {foreignKeyName} on table {tableName}, unable to find the column called {principalColumnName} on the foreign key's principal table, {principaltableName}. Skipping foreign key.</value>
    <comment>Warning GaussDBEventId.ForeignKeyPrincipalColumnMissingWarning string string string string</comment>
  </data>
  <data name="LogPrincipalTableNotInSelectionSet" xml:space="preserve">
    <value>For foreign key {fkName} on table {tableName}, unable to model the end of the foreign key on principal table {principaltableName}. This is usually because the principal table was not included in the selection set.</value>
    <comment>Warning GaussDBEventId.ForeignKeyReferencesMissingPrincipalTableWarning string? string? string?</comment>
  </data>
  <data name="LogUnsupportedColumnConstraintSkipped" xml:space="preserve">
    <value>Constraint '{name}' on table {tableName} cannot be scaffolded because it includes a column that cannot be scaffolded (e.g. enum).</value>
    <comment>Warning GaussDBEventId.UnsupportedColumnConstraintSkippedWarning string? string</comment>
  </data>
  <data name="LogUnsupportedColumnIndexSkipped" xml:space="preserve">
    <value>Index '{name}' on table {tableName} cannot be scaffolded because it includes a column that cannot be scaffolded (e.g. enum).</value>
    <comment>Warning GaussDBEventId.UnsupportedColumnIndexSkippedWarning string string</comment>
  </data>
  <data name="NonKeyValueGeneration" xml:space="preserve">
    <value>The property '{property}' on entity type '{entityType}' is configured to use 'SequenceHiLo' value generator, which is only intended for keys. If this was intentional configure an alternate key on the property, otherwise call 'ValueGeneratedNever' or configure store generation for this property.</value>
  </data>
  <data name="SequenceBadType" xml:space="preserve">
    <value>PostgreSQL sequences cannot be used to generate values for the property '{property}' on entity type '{entityType}' because the property type is '{propertyType}'. Sequences can only be used with integer properties.</value>
  </data>
  <data name="TransientExceptionDetected" xml:space="preserve">
    <value>An exception has been raised that is likely due to a transient failure. Consider enabling transient error resiliency by adding 'EnableRetryOnFailure()' to the 'UseSqlServer' call.</value>
  </data>
  <data name="IdentityBadType" xml:space="preserve">
    <value>Identity value generation cannot be used for the property '{property}' on entity type '{entityType}' because the property type is '{propertyType}'. Identity value generation can only be used with signed integer properties.</value>
  </data>
  <data name="RowValueComparisonRequiresTuplesOfSameLength" xml:space="preserve">
    <value>Row values comparisons require two tuple arguments of the same length.</value>
  </data>
  <data name="CannotUseDataSourceWithAuthCallbacks" xml:space="preserve">
    <value>Cannot set ProvideClientCertificatesCallback, RemoteCertificateValidationCallback or ProvidePasswordCallback when a data source is provided.</value>
  </data>
  <data name="StoredProcedureResultColumnsNotSupported" xml:space="preserve">
    <value>The entity type '{entityType}' is mapped to the stored procedure '{sproc}', which is configured with result columns. PostgreSQL stored procedures do not support result columns; use output parameters instead.</value>
  </data>
  <data name="StoredProcedureReturnValuesNotSupported" xml:space="preserve">
    <value>The entity type '{entityType}' is mapped to the stored procedure '{sproc}', which is configured with result columns. PostgreSQL stored procedures do not support return values; use output parameters instead.</value>
  </data>
  <data name="StoredProcedureReturnValueNotSupported" xml:space="preserve">
    <value>The entity type '{entityType}' is mapped to the stored procedure '{sproc}', which is configured with result columns. PostgreSQL stored procedures do not support return values; use output parameters instead.</value>
  </data>
  <data name="TwoDataSourcesInSameServiceProvider" xml:space="preserve">
    <value>Using two distinct data sources within a service provider is not supported, and Entity Framework is not building its own internal service provider. Either allow Entity Framework to build the service provider by removing the call to '{useInternalServiceProvider}', or ensure that the same data source is used for all uses of a given service provider passed to '{useInternalServiceProvider}'.</value>
  </data>
</root>